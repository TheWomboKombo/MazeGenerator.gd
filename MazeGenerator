extends TileMap

var rng = RandomNumberGenerator.new()
var numberOfPickups = 0

enum Tiles {
	ground = 0, #light green
	wall = 1, #dark green
	blue = 2, 
	yellow = 3, 
	red = 4, 
	pink = 5 
}

export var width = 48
export var height = 26

var start_x
var start_y
var end_x
var end_y

var generation_complete = false

func _ready():
	# assert uneven number
	if width % 2 != 1:
		width -= 1
	if height % 2 != 1:
		height -= 1
	
	var x_scale = 1920/(width*32)
	var y_scale = 1080/(height*32)
	scale = Vector2(x_scale, y_scale)
	
	for i in range(width):
		for j in range(height):
			# surrounding wall
			if i == 0 or j == 0 or i == width-1 or j == height-1:
				set_cell(i, j, Tiles.wall)
			# regular wall
			elif i%2 == 0 or j%2 == 0:
				set_cell(i, j, Tiles.wall)
			# floor
			else:
				set_cell(i, j, Tiles.blue)
	
	randomize()
	
	start_x = 0
	start_y = 3
	
	end_x = width-1
	end_y = height-4
	
	set_cell(start_x, start_y, Tiles.red)
	set_cell(end_x, end_y, Tiles.yellow)
	
	rdf_init()


func _physics_process(_delta):
	if not generation_complete:
		rdf_step()
		generate_pickup()


var rdf_stack = []
func rdf_init():
	var offsets = [[1, 0], [-1, 0], [0, 1], [0, -1]]
	
	for o in offsets:
		if get_cell(start_x + o[0], start_y + o[1]) == Tiles.blue:
			rdf_stack.push_back(Vector2(start_x + o[0], start_y + o[1]))
	set_cellv(rdf_stack[0], Tiles.wall)

func rdf_step():
	if len(rdf_stack) <= 0:
		generation_complete = true
		return
	
	var curr = rdf_stack.pop_back()
	var next
	var found = false
	
	# check neighbors in random order
	var check_order = [[2,0], [-2, 0], [0, 2], [0, -2]]
	check_order.shuffle()
	for val in check_order:
		next = Vector2(val[0], val[1])
		if get_cellv(curr + next) == Tiles.blue:
			found = true
			break
	
	if found:
		
		#random number for pickups
		rng.randomize()
		var pickups = rng.randf_range(1, 10)
		
		
		rdf_stack.push_back(curr)
		
		
		if(pickups < 1.3 and numberOfPickups < 10):
			numberOfPickups +=1
			set_cellv(curr + (next/2), Tiles.pink)
			print(numberOfPickups)
		else:
			set_cellv(curr + (next/2), Tiles.yellow)
			
			
		set_cellv(curr + next, Tiles.wall)
		set_cellv(curr, Tiles.yellow)
		rdf_stack.push_back(curr+next)
	else:
		set_cellv(curr, Tiles.ground)
		for dir in [[1,0], [0,1], [-1,0], [0,-1]]:
			var dir_vec = Vector2(dir[0], dir[1])
			if get_cellv(curr+dir_vec) == Tiles.yellow and get_cellv(curr+(dir_vec*2)) == Tiles.ground:
				set_cellv(curr+dir_vec, Tiles.ground)
		if len(rdf_stack) > 0 and rdf_stack[0] != null:
			set_cellv(rdf_stack.back(), Tiles.wall)


onready var pickup_scene = preload("res://Pickup.tscn")

func spawn_pickup(tile_position: Vector2):
	var instance = pickup_scene.instance()
	add_child(instance)
	instance.position = tile_position

func generate_pickup() -> void:
	for tile_position in get_used_cells():
		if get_cellv(tile_position) == tile_set.find_tile_by_name("wall"):
			var tile_world_position = map_to_world(tile_position)
			spawn_pickup(tile_world_position)
